
HOOK EXAMPLE 1:\n\n\n    SUMMARY: A simple hook that has 4 counters per PoolId - beforeSwap, afterSwap, beforeAddLiquidity, afterAddLiquidity\n\n    CODE:\n // SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\n\nimport {Hooks} from "v4-core/src/libraries/Hooks.sol";\nimport {IPoolManager} from "v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolKey} from "v4-core/src/types/PoolKey.sol";\nimport {PoolId, PoolIdLibrary} from "v4-core/src/types/PoolId.sol";\nimport {BalanceDelta} from "v4-core/src/types/BalanceDelta.sol";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "v4-core/src/types/BeforeSwapDelta.sol";\n\ncontract Counter is BaseHook {\n    using PoolIdLibrary for PoolKey;\n\n    // NOTE: ---------------------------------------------------------\n    // state variables should typically be unique to a pool\n    // a single hook contract should be able to service multiple pools\n    // ---------------------------------------------------------------\n\n    mapping(PoolId => uint256 count) public beforeSwapCount;\n    mapping(PoolId => uint256 count) public afterSwapCount;\n\n    mapping(PoolId => uint256 count) public beforeAddLiquidityCount;\n    mapping(PoolId => uint256 count) public beforeRemoveLiquidityCount;\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeAddLiquidity: true,\n            afterAddLiquidity: false,\n            beforeRemoveLiquidity: true,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    // -----------------------------------------------\n    // NOTE: see IHooks.sol for function documentation\n    // -----------------------------------------------\n\n    function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)\n        external\n        override\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        beforeSwapCount[key.toId()]++;\n        return (BaseHook.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, BalanceDelta, bytes calldata)\n        external\n        override\n        returns (bytes4, int128)\n    {\n        afterSwapCount[key.toId()]++;\n        return (BaseHook.afterSwap.selector, 0);\n    }\n\n    function beforeAddLiquidity(\n        address,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) external override returns (bytes4) {\n        beforeAddLiquidityCount[key.toId()]++;\n        return BaseHook.beforeAddLiquidity.selector;\n    }\n\n    function beforeRemoveLiquidity(\n        address,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) external override returns (bytes4) {\n        beforeRemoveLiquidityCount[key.toId()]++;\n        return BaseHook.beforeRemoveLiquidity.selector;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 2:\n\n\n    SUMMARY: Imagine you have some memecoin-type coin called TOKEN. We want to attach our hook into ETH <> TOKEN pools. Our goal is to incentivize swappers to buy TOKEN in exchange for ETH, and for LPs to add liquidity to our pool. Also, we want to allow people to refer other users such that the referrer will earn some commission every time the referree buys TOKEN for ETH or adds liquidity to the pool. This incentivization happens through the hook issuing a second POINTS token when desired actions occur. For simplicity, we\'ll set some basic rules and assumptions: When a user gets referred, we will mint a hardcoded amount of POINTS token to the referrer - in our case, 500 POINTS. When a swap takes place which buys TOKEN for ETH - we will issue POINTS equivalent to how much ETH was swapped in to the user, and 10% of that amount to the referrer (if any). When someone adds liquidity, we will issue POINTS equivalent to how much ETH they added, and 10% of that amount to the referrer (if any).\n\n    CODE:\n // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\nimport {ERC20} from "solmate/tokens/ERC20.sol";\n\nimport {CurrencyLibrary, Currency} from "v4-core/types/Currency.sol";\nimport {PoolKey} from "v4-core/types/PoolKey.sol";\nimport {BalanceDeltaLibrary, BalanceDelta} from "v4-core/types/BalanceDelta.sol";\n\nimport {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";\n\nimport {Hooks} from "v4-core/libraries/Hooks.sol";\n\ncontract PointsHook is BaseHook, ERC20 {\n\t// Use CurrencyLibrary and BalanceDeltaLibrary\n\t// to add some helper functions over the Currency and BalanceDelta\n\t// data types \n\tusing CurrencyLibrary for Currency;\n    using BalanceDeltaLibrary for BalanceDelta;\n\n\t// Keeping track of user => referrer\n\tmapping(address => address) public referredBy;\n\n\t// Amount of points someone gets for referring someone else\n    uint256 public constant POINTS_FOR_REFERRAL = 500 * 10 ** 18;\n\n\t// Initialize BaseHook and ERC20\n    constructor(\n        IPoolManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) BaseHook(_manager) ERC20(_name, _symbol, 18) {}\n\n\t// Set up hook permissions to return `true`\n\t// for the two hook functions we are using\n    function getHookPermissions()\n        public\n        pure\n        override\n        returns (Hooks.Permissions memory)\n    {\n        return\n            Hooks.Permissions({\n                beforeInitialize: false,\n                afterInitialize: false,\n                beforeAddLiquidity: false,\n                beforeRemoveLiquidity: false,\n                afterAddLiquidity: true,\n                afterRemoveLiquidity: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata swapParams,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external override poolManagerOnly returns (bytes4) {\n        // If this is not an ETH-TOKEN pool with this hook attached, ignore\n        // `isNative` function comes from CurrencyLibrary\n        if (!key.currency0.isNative()) return this.afterSwap.selector;\n\n        // We only mint points if user is buying TOKEN with ETH\n        if (!swapParams.zeroForOne) return this.afterSwap.selector;\n\n        // Mint points equal to 20% of the amount of ETH they spent\n        // Since its a zeroForOne swap:\n        // if amountSpecified < 0:\n        //      this is an "exact input for output" swap\n        //      amount of ETH they spent is equal to |amountSpecified|\n        // if amountSpecified > 0:\n        //      this is an "exact output for input" swap\n        //      amount of ETH they spent is equal to BalanceDelta.amount0()\n\n        uint256 ethSpendAmount = swapParams.amountSpecified < 0\n            ? uint256(-swapParams.amountSpecified)\n            // amount0() function here comes from BalanceDeltaLibrary\n            : uint256(int256(-delta.amount0()));\n\n        // pointsForSwap = 20% of ethSpendAmount\n        uint256 pointsForSwap = ethSpendAmount / 5;\n\n        // Mint the points including any referral points\n        _assignPoints(hookData, pointsForSwap);\n\n        return this.afterSwap.selector;\n    }\n\n    function afterAddLiquidity(\n        address,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external override poolManagerOnly returns (bytes4) {\n        // If this is not an ETH-TOKEN pool with this hook attached, ignore\n        if (!key.currency0.isNative()) return this.afterSwap.selector;\n\n        // Mint points equivalent to how much ETH they\'re adding in liquidity\n        // amount0() is amount of Token 0 i.e. ETH\n        // we do `-amount0` because its money leaving the user\'s wallet so will be a negative value, we flip the sign to make it positive\n        uint256 pointsForAddingLiquidity = uint256(int256(-delta.amount0()));\n\n        // Mint the points including any referral points\n        _assignPoints(hookData, pointsForAddingLiquidity);\n\n        return this.afterAddLiquidity.selector;\n    }\n    \n    function getHookData(\n        address referrer,\n        address referree\n    ) public pure returns (bytes memory) {\n        return abi.encode(referrer, referree);\n    }\n\n    function _assignPoints(\n        bytes calldata hookData,\n        uint256 referreePoints\n    ) internal {\n\n        // If no referrer/referree specified, no points will be assigned to anyone\n        if (hookData.length == 0) return;\n\n        // Decode the referrer and referree addresses\n        (address referrer, address referree) = abi.decode(\n            hookData,\n            (address, address)\n        );\n\n        // If referree is the zero address, ignore\n        if (referree == address(0)) return;\n\n        // If this referree is being referred by someone for the first time,\n        // set the given referrer address as their referrer\n        // and mint POINTS_FOR_REFERRAL to that referrer address\n        if (referredBy[referree] == address(0) && referrer != address(0)) {\n            referredBy[referree] = referrer;\n            _mint(referrer, POINTS_FOR_REFERRAL);\n        }\n\n        // Mint 10% worth of the referree\'s points to the referrer\n        if (referredBy[referree] != address(0)) {\n            _mint(referrer, referreePoints / 10);\n        }\n\n        // Mint the appropriate number of points to the referree\n        _mint(referree, referreePoints);\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 3:\n\n\n    SUMMARY: Allows for Know Your Customer (KYC) checks to be performed on users before they are allowed to trade on a pool. This can be used to prevent fraud and ensure that only legitimate users are able to trade.\n\n    CODE:\n // SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.19;\n\nimport {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";\nimport {IPoolManager} from "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol";\nimport {Hooks} from "@uniswap/v4-core/contracts/libraries/Hooks.sol";\n\nimport {BaseHook} from "./BaseHook.sol";\n\n/**\n * @title An interface for checking whether an address has a valid kycNFT token\n */\ninterface IKycValidity {\n    /// @dev Check whether a given address has a valid kycNFT token\n    /// @param _addr Address to check for tokens\n    /// @return valid Whether the address has a valid token\n    function hasValidToken(address _addr) external view returns (bool valid);\n}\n\n/**\n * Only KYC\'ed people can trade on the V4 hook\'ed pool.\n * Caveat: Relies on external oracle for info on an address\'s KYC status.\n */\ncontract KYCSwaps is BaseHook, Ownable {\n    IKycValidity public kycValidity;\n    address private _preKycValidity;\n    uint256 private _setKycValidityReqTimestamp;\n\n    constructor(\n        IPoolManager _poolManager,\n        address _kycValidity\n    ) BaseHook(_poolManager) {\n        kycValidity = IKycValidity(_kycValidity);\n    }\n\n    modifier onlyPermitKYC() {\n        require(\n            kycValidity.hasValidToken(tx.origin),\n            "Swaps available for valid KYC token holders"\n        );\n        _;\n    }\n\n    /// Sorta timelock\n    function setKycValidity(address _kycValidity) external onlyOwner {\n        if (\n            block.timestamp - _setKycValidityReqTimestamp >= 7 days &&\n            _kycValidity == _preKycValidity\n        ) {\n            kycValidity = IKycValidity(_kycValidity);\n        } else {\n            _preKycValidity = _kycValidity;\n            _setKycValidityReqTimestamp = block.timestamp;\n        }\n    }\n\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return\n            Hooks.Calls({\n                beforeInitialize: false,\n                afterInitialize: false,\n                beforeModifyPosition: true,\n                afterModifyPosition: false,\n                beforeSwap: true,\n                afterSwap: false,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    function beforeModifyPosition(\n        address,\n        IPoolManager.PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata\n    ) external view override poolManagerOnly onlyPermitKYC returns (bytes4) {\n        return BaseHook.beforeModifyPosition.selector;\n    }\n\n    function beforeSwap(\n        address,\n        IPoolManager.PoolKey calldata,\n        IPoolManager.SwapParams calldata\n    ) external view override poolManagerOnly onlyPermitKYC returns (bytes4) {\n        return BaseHook.beforeSwap.selector;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 4:\n\n\n    SUMMARY: A hook that keeps track of the moving average gas price over time onchain. When gas price is roughly equal to the average, we will charge a certain amount of fees. If gas price is over 10% higher than the average, we will charge lower fees. If gas price is at least 10% lower than the average, we will charge higher fees.\n\n    CODE:\n // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\nimport {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";\nimport {Hooks} from "v4-core/libraries/Hooks.sol";\nimport {PoolKey} from "v4-core/types/PoolKey.sol";\nimport {BalanceDelta} from "v4-core/types/BalanceDelta.sol";\nimport {LPFeeLibrary} from "v4-core/libraries/LPFeeLibrary.sol";\nimport {BeforeSwapDelta, toBeforeSwapDelta} from "v4-core/types/BeforeSwapDelta.sol";\n\ncontract GasPriceFeesHook is BaseHook {\n    using LPFeeLibrary for uint24;\n\n    // Keeping track of the moving average gas price\n    uint128 public movingAverageGasPrice;\n    // How many times has the moving average been updated?\n    // Needed as the denominator to update it the next time based on the moving average formula\n    uint104 public movingAverageGasPriceCount;\n\n    // The default base fees we will charge\n    uint24 public constant BASE_FEE = 5000; // 0.5%\n\n    error MustUseDynamicFee();\n\n    // Initialize BaseHook parent contract in the constructor\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {\n        updateMovingAverage();\n    }\n\n    // Required override function for BaseHook to let the PoolManager know which hooks are implemented\n    function getHookPermissions()\n        public\n        pure\n        override\n        returns (Hooks.Permissions memory)\n    {\n        return\n            Hooks.Permissions({\n                beforeInitialize: true,\n                afterInitialize: false,\n                beforeAddLiquidity: false,\n                beforeRemoveLiquidity: false,\n                afterAddLiquidity: false,\n                afterRemoveLiquidity: false,\n                beforeSwap: true,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false,\n                beforeSwapReturnDelta: false,\n                afterSwapReturnDelta: false,\n                afterAddLiquidityReturnDelta: false,\n                afterRemoveLiquidityReturnDelta: false\n            });\n    }\n\n    function beforeInitialize(\n        address,\n        PoolKey calldata key,\n        uint160,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        // `.isDynamicFee()` function comes from using\n        // the `SwapFeeLibrary` for `uint24`\n        if (!key.fee.isDynamicFee()) revert MustUseDynamicFee();\n        return this.beforeInitialize.selector;\n    }\n\n    function beforeSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    )\n        external\n        override\n        onlyByManager\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        uint24 fee = getFee();\n        manager.updateDynamicLPFee(key, fee);\n        return (this.beforeSwap.selector, toBeforeSwapDelta(0, 0), 0);\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external override returns (bytes4, int128) {\n        updateMovingAverage();\n        return (this.afterSwap.selector, 0);\n    }\n\n    function getFee() internal view returns (uint24) {\n        uint128 gasPrice = getGasPrice();\n\n        // if gasPrice > movingAverageGasPrice * 1.1, then half the fees\n        if (gasPrice > (movingAverageGasPrice * 11) / 10) {\n            return BASE_FEE / 2;\n        }\n\n        // if gasPrice < movingAverageGasPrice * 0.9, then double the fees\n        if (gasPrice < (movingAverageGasPrice * 9) / 10) {\n            return BASE_FEE * 2;\n        }\n\n        return BASE_FEE;\n    }\n\n    // Update our moving average gas price\n    function updateMovingAverage() internal {\n        uint128 gasPrice = getGasPrice();\n\n        // New Average = ((Old Average * # of Txns Tracked) + Current Gas Price) / (# of Txns Tracked + 1)\n        movingAverageGasPrice =\n            ((movingAverageGasPrice * movingAverageGasPriceCount) + gasPrice) /\n            (movingAverageGasPriceCount + 1);\n\n        movingAverageGasPriceCount++;\n    }\n\n    // Gets the current gas price of this transaction\n    // There is no high-level function in Solidity for this, but Solidity-assembly allows this\n    function getGasPrice() public view returns (uint128) {\n        uint128 gasPrice;\n        assembly {\n            gasPrice := gasprice()\n        }\n        return gasPrice;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 5:\n\n\n    SUMMARY: Requires multiple signatures for certain pool actions, such as adding or removing liquidity. This can be used to add an extra layer of security to a pool.\n\n    CODE:\n pragma solidity ^0.8.15;\n\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\nimport {Hooks} from "@uniswap/v4-core/contracts/libraries/Hooks.sol";\nimport {IPoolManager} from "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol";\nimport {PoolId, PoolIdLibrary} from "@uniswap/v4-core/contracts/libraries/PoolId.sol";\nimport {BalanceDelta} from "@uniswap/v4-core/contracts/types/BalanceDelta.sol";\n\ncontract MultiSigSwapHook is BaseHook {\n    struct SwapApproval {\n        uint256 count;\n        mapping(address => bool) signers;\n    }\n\n    using PoolIdLibrary for IPoolManager.PoolKey;\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, "Caller is not the owner");\n        _;\n    }\n\n    address public owner;\n\n    mapping(bytes32 => SwapApproval) public swapApprovals;\n    mapping(address => bool) public authorizedSigners;\n    uint256 public requiredSignatures;\n\n    event ApprovalAdded(address indexed signer, bytes32 indexed swapHash);\n    event SwapCompleted(bytes32 indexed swapHash);\n\n    constructor(IPoolManager _poolManager, address[] memory _signers, uint256 _requiredSignatures) BaseHook(_poolManager) {\n        require(_signers.length >= _requiredSignatures, "Invalid signers or required signatures");\n        require(_requiredSignatures > 0, "At least one signature is required");\n\n        for (uint i = 0; i < _signers.length; i++) {\n            require(!authorizedSigners[_signers[i]], "Duplicate signers are not allowed");\n            authorizedSigners[_signers[i]] = true;\n        }\n\n        requiredSignatures = _requiredSignatures;\n        owner = msg.sender;\n    }\n\n    function approveSwap(bytes32 swapHash) public {\n        require(authorizedSigners[msg.sender], "Not an approved signer");\n        require(!swapApprovals[swapHash].signers[msg.sender], "Signer has already approved this swap");\n\n        swapApprovals[swapHash].count++;\n        swapApprovals[swapHash].signers[msg.sender] = true;\n\n        emit ApprovalAdded(msg.sender, swapHash);\n    }\n\n    function beforeSwap(address, IPoolManager.PoolKey calldata, IPoolManager.SwapParams calldata swapParams)\n    external\n    override\n    returns (bytes4)\n    {\n        bytes32 swapHash = keccak256(abi.encode(swapParams));\n        require(swapApprovals[swapHash].count >= requiredSignatures, "Insufficient approvals for swap");\n\n        return BaseHook.beforeSwap.selector;\n    }\n\n    function afterSwap(address, IPoolManager.PoolKey calldata, IPoolManager.SwapParams calldata swapParams, BalanceDelta)\n    external\n    override\n    returns (bytes4)\n    {\n        bytes32 swapHash = keccak256(abi.encode(swapParams));\n        delete swapApprovals[swapHash]; // Clears the swap approval for the swapHash\n\n        emit SwapCompleted(swapHash);\n        return BaseHook.afterSwap.selector;\n    }\n\n\n    function addSigner(address signer) public onlyOwner {\n        require(!authorizedSigners[signer], "Signer is already authorized");\n        authorizedSigners[signer] = true;\n    }\n\n\n    function removeSigner(address signer) public onlyOwner {\n        require(authorizedSigners[signer], "Signer is not authorized");\n        authorizedSigners[signer] = false;\n    }\n\n\n    function setRequiredSignatures(uint256 _requiredSignatures) public onlyOwner {\n        require(_requiredSignatures > 0, "At least one signature is required");\n        requiredSignatures = _requiredSignatures;\n    }\n\n    function getApprovalDetails(bytes32 swapHash) public view returns (uint256 approvalCount, bool hasSigned) {\n        return (swapApprovals[swapHash].count, swapApprovals[swapHash].signers[msg.sender]);\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 6:\n\n\n    SUMMARY: A hook that allows users to place \'take-profit\' positions. For example, in an ETH/DAI pool if currently 1 ETH = 1500 DAI, you could place a take-profit order as \'sell all my ETH when 1 ETH = 2000 DAI\' which will be executed automatically.\n\n    CODE:\n // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {BaseHook} from "periphery-next/BaseHook.sol";\nimport {ERC1155} from "openzeppelin-contracts/contracts/token/ERC1155/ERC1155.sol";\nimport {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";\nimport {Hooks} from "v4-core/libraries/Hooks.sol";\nimport {PoolId, PoolIdLibrary} from "v4-core/types/PoolId.sol";\nimport {Currency, CurrencyLibrary} from "v4-core/types/Currency.sol";\nimport {PoolKey} from "v4-core/types/PoolKey.sol";\nimport {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";\nimport {TickMath} from "v4-core/libraries/TickMath.sol";\nimport {BalanceDelta} from "v4-core/types/BalanceDelta.sol";\nimport {FixedPointMathLib} from "solmate/utils/FixedPointMathLib.sol";\nimport "forge-std/console.sol";\n\ncontract TakeProfitsHook is BaseHook, ERC1155 {\n    // Use the PoolIdLibrary for PoolKey to add the `.toId()` function on a PoolKey\n    // which hashes the PoolKey struct into a bytes32 value\n    using PoolIdLibrary for PoolKey;\n\n    // Use the CurrencyLibrary for the Currency struct\n    using CurrencyLibrary for Currency;\n\n    // Use the FixedPointMathLib for doing math operations on uint256 values\n    using FixedPointMathLib for uint256;\n\n    // Create a mapping to store the last known tickLower value for a given Pool\n    mapping(PoolId poolId => int24 tickLower) public tickLowerLasts;\n\n    // Create a nested mapping to store the take-profit orders placed by users\n    // The mapping is PoolId => tickLower => zeroForOne => amount\n    // PoolId => (...) specifies the ID of the pool the order is for\n    // tickLower => (...) specifies the tickLower value of the order i.e. sell when price is greater than or equal to this tick\n    // zeroForOne => (...) specifies whether the order is swapping Token 0 for Token 1 (true), or vice versa (false)\n    // amount specifies the amount of the token being sold\n    mapping(PoolId poolId => mapping(int24 tick => mapping(bool zeroForOne => int256 amount)))\n        public takeProfitPositions;\n\n    // tokenIdExists is a mapping to store whether a given tokenId (i.e. a take-profit order) exists given a token id\n    mapping(uint256 tokenId => bool exists) public tokenIdExists;\n    // tokenIdClaimable is a mapping that stores how many swapped tokens are claimable for a given tokenId\n    mapping(uint256 tokenId => uint256 claimable) public tokenIdClaimable;\n    // tokenIdTotalSupply is a mapping that stores how many tokens need to be sold to execute the take-profit order\n    mapping(uint256 tokenId => uint256 supply) public tokenIdTotalSupply;\n    // tokenIdData is a mapping that stores the PoolKey, tickLower, and zeroForOne values for a given tokenId\n    mapping(uint256 tokenId => TokenData) public tokenIdData;\n\n    struct TokenData {\n        PoolKey poolKey;\n        int24 tick;\n        bool zeroForOne;\n    }\n\n    // Initialize BaseHook and ERC1155 parent contracts in the constructor\n    constructor(\n        IPoolManager _poolManager,\n        string memory _uri\n    ) BaseHook(_poolManager) ERC1155(_uri) {}\n\n    // Required override function for BaseHook to let the PoolManager know which hooks are implemented\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return\n            Hooks.Calls({\n                beforeInitialize: false,\n                afterInitialize: true,\n                beforeModifyPosition: false,\n                afterModifyPosition: false,\n                beforeSwap: false,\n                afterSwap: true,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    // Hooks\n    function afterInitialize(\n        address,\n        PoolKey calldata key,\n        uint160,\n        int24 tick\n    ) external override poolManagerOnly returns (bytes4) {\n        _setTickLowerLast(key.toId(), _getTickLower(tick, key.tickSpacing));\n        return TakeProfitsHook.afterInitialize.selector;\n    }\n\n    function afterSwap(\n        address addr,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta \n    ) external override poolManagerOnly returns (bytes4) {\n        if (addr == address(this)) {\n            return TakeProfitsHook.afterSwap.selector;\n        }\n\n        bool attemptToFillMoreOrders = true;\n        int24 currentTickLower;\n        while (attemptToFillMoreOrders) {\n            (attemptToFillMoreOrders, currentTickLower) = _tryFulfillingOrders(key, params);\n            tickLowerLasts[key.toId()] = currentTickLower;\n        }\n\n        return TakeProfitsHook.afterSwap.selector;\n    }\n\n    function _tryFulfillingOrders(PoolKey calldata key, IPoolManager.SwapParams calldata params) internal returns (bool, int24) {\n        // Get the exact current tick and use it to calculate the currentTickLower\n        (, int24 currentTick, , , , ) = poolManager.getSlot0(key.toId());\n        int24 currentTickLower = _getTickLower(currentTick, key.tickSpacing);\n        int24 lastTickLower = tickLowerLasts[key.toId()];\n\n        bool swapZeroForOne = !params.zeroForOne;\n\n        int256 swapAmountIn;\n\n        // If tick has increased (i.e. price of Token 1 has increased)\n        if (lastTickLower < currentTickLower) {\n            // Loop through all ticks between the lastTickLower and currentTickLower\n            // and execute all orders that are oneForZero\n            for (int24 tick = lastTickLower; tick < currentTickLower; ) {\n                swapAmountIn = takeProfitPositions[key.toId()][tick][\n                    swapZeroForOne\n                ];\n                if (swapAmountIn > 0) {\n                    fillOrder(key, tick, swapZeroForOne, swapAmountIn);\n\n                    // The fulfillment of the above order has changed the current tick\n                    // Refetch it and return\n                    (, currentTick, , , , ) = poolManager.getSlot0(key.toId());\n                    currentTickLower = _getTickLower(currentTick, key.tickSpacing);\n                    return (true, currentTickLower);\n                }\n                tick += key.tickSpacing;\n            }\n        }\n        // Else if tick has decreased (i.e. price of Token 0 has increased)\n        else {\n            // Loop through all ticks between the lastTickLower and currentTickLower\n            // and execute all orders that are zeroForOne\n            for (int24 tick = lastTickLower; currentTickLower < tick; ) {\n                swapAmountIn = takeProfitPositions[key.toId()][tick][\n                    swapZeroForOne\n                ];\n                if (swapAmountIn > 0) {\n                    fillOrder(key, tick, swapZeroForOne, swapAmountIn);\n\n                    // The fulfillment of the above order has changed the current tick\n                    // Refetch it and return\n                    (, currentTick, , , , ) = poolManager.getSlot0(key.toId());\n                    currentTickLower = _getTickLower(currentTick, key.tickSpacing);\n                    return (true, currentTickLower);\n                }\n                tick -= key.tickSpacing;\n            }\n        }\n\n        return (false, currentTickLower);\n    }\n\n    // Core Utilities\n    function placeOrder(\n        PoolKey calldata key,\n        int24 tick,\n        uint256 amountIn,\n        bool zeroForOne\n    ) external returns (int24) {\n        int24 tickLower = _getTickLower(tick, key.tickSpacing);\n        takeProfitPositions[key.toId()][tickLower][zeroForOne] += int256(\n            amountIn\n        );\n\n        uint256 tokenId = getTokenId(key, tickLower, zeroForOne);\n        // If token id doesn\'t already exist, add it to the mapping\n        // Not every order creates a new token id, as it\'s possible for users to add more tokens to a pre-existing order\n        if (!tokenIdExists[tokenId]) {\n            tokenIdExists[tokenId] = true;\n            tokenIdData[tokenId] = TokenData(key, tickLower, zeroForOne);\n        }\n\n        // Mint ERC-1155 tokens to the user\n        _mint(msg.sender, tokenId, amountIn, "");\n        tokenIdTotalSupply[tokenId] += amountIn;\n\n        // Extract the address of the token the user wants to sell\n        address tokenToBeSoldContract = zeroForOne\n            ? Currency.unwrap(key.currency0)\n            : Currency.unwrap(key.currency1);\n\n        // Move the tokens to be sold from the user to this contract\n        IERC20(tokenToBeSoldContract).transferFrom(\n            msg.sender,\n            address(this),\n            amountIn\n        );\n\n        return tickLower;\n    }\n\n    function cancelOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne\n    ) external {\n        int24 tickLower = _getTickLower(tick, key.tickSpacing);\n        uint256 tokenId = getTokenId(key, tickLower, zeroForOne);\n\n        // Get the amount of tokens the user\'s ERC-1155 tokens represent\n        uint256 amountIn = balanceOf(msg.sender, tokenId);\n        require(amountIn > 0, "TakeProfitsHook: No orders to cancel");\n\n        takeProfitPositions[key.toId()][tickLower][zeroForOne] -= int256(\n            amountIn\n        );\n        tokenIdTotalSupply[tokenId] -= amountIn;\n        _burn(msg.sender, tokenId, amountIn);\n\n        // Extract the address of the token the user wanted to sell\n        address tokenToBeSoldContract = zeroForOne\n            ? Currency.unwrap(key.currency0)\n            : Currency.unwrap(key.currency1);\n        // Move the tokens to be sold from this contract back to the user\n        IERC20(tokenToBeSoldContract).transfer(msg.sender, amountIn);\n    }\n\n    function fillOrder(\n        PoolKey calldata key,\n        int24 tick,\n        bool zeroForOne,\n        int256 amountIn\n    ) internal {\n\n        console.log("Filling order at tick = ");\n        console.logInt(tick);\n\n        // Setup the swapping parameters\n        IPoolManager.SwapParams memory swapParams = IPoolManager.SwapParams({\n            zeroForOne: zeroForOne,\n            amountSpecified: amountIn,\n            // Set the price limit to be the least possible if swapping from Token 0 to Token 1\n            // or the maximum possible if swapping from Token 1 to Token 0\n            // i.e. infinite slippage allowed\n            sqrtPriceLimitX96: zeroForOne\n                ? TickMath.MIN_SQRT_RATIO + 1\n                : TickMath.MAX_SQRT_RATIO - 1\n        });\n\n        BalanceDelta delta = abi.decode(\n            poolManager.lock(\n                abi.encodeCall(this._handleSwap, (key, swapParams))\n            ),\n            (BalanceDelta)\n        );\n\n        // Update mapping to reflect that `amountIn` worth of tokens have been swapped from this order\n        takeProfitPositions[key.toId()][tick][zeroForOne] -= amountIn;\n\n        uint256 tokenId = getTokenId(key, tick, zeroForOne);\n\n        // Flip the sign of the delta as tokens we were owed by Uniswap are represented as a negative delta change\n        uint256 amountOfTokensReceivedFromSwap = zeroForOne\n            ? uint256(int256(-delta.amount1()))\n            : uint256(int256(-delta.amount0()));\n\n        // Update the amount of tokens claimable for this order\n        tokenIdClaimable[tokenId] += amountOfTokensReceivedFromSwap;\n    }\n\n    function _handleSwap(\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params\n    ) external returns (BalanceDelta) {\n        // delta is the BalanceDelta struct that stores the delta balance changes\n        // i.e. Change in Token 0 balance and change in Token 1 balance\n        BalanceDelta delta = poolManager.swap(key, params);\n\n        // If this swap was a swap for Token 0 to Token 1\n        if (params.zeroForOne) {\n            // If we owe Uniswap Token 0, we need to send them the required amount\n            if (delta.amount0() > 0) {\n                IERC20(Currency.unwrap(key.currency0)).transfer(\n                    address(poolManager),\n                    uint128(delta.amount0())\n                );\n                poolManager.settle(key.currency0);\n            }\n\n            // If we are owed Token 1, we need to `take` it from the Pool Manager\n            // NOTE: This will be a negative value, as it is a negative balance change from the pool\'s perspective\n            if (delta.amount1() < 0) {\n                // We flip the sign of the amount to make it positive when taking it from the pool manager\n                poolManager.take(\n                    key.currency1,\n                    address(this),\n                    uint128(-delta.amount1())\n                );\n            }\n        }\n        // Else if this swap was a swap for Token 1 to Token 0\n        else {\n            // Same as above\n            // If we owe Uniswap Token 1, we need to send them the required amount\n            if (delta.amount1() > 0) {\n                IERC20(Currency.unwrap(key.currency1)).transfer(\n                    address(poolManager),\n                    uint128(delta.amount1())\n                );\n                poolManager.settle(key.currency1);\n            }\n\n            // If we are owed Token 0, we take it from the Pool Manager\n            if (delta.amount0() < 0) {\n                poolManager.take(\n                    key.currency0,\n                    address(this),\n                    uint128(-delta.amount0())\n                );\n            }\n        }\n\n        return delta;\n    }\n\n    function redeem(\n        uint256 tokenId,\n        uint256 amountIn,\n        address destination\n    ) external {\n        // Make sure there is something to claim\n        require(\n            tokenIdClaimable[tokenId] > 0,\n            "TakeProfitsHook: No tokens to redeem"\n        );\n\n        // Make sure user has enough ERC-1155 tokens to redeem the amount they\'re requesting\n        uint256 balance = balanceOf(msg.sender, tokenId);\n        require(\n            balance >= amountIn,\n            "TakeProfitsHook: Not enough ERC-1155 tokens to redeem requested amount"\n        );\n\n        TokenData memory data = tokenIdData[tokenId];\n        address tokenToSendContract = data.zeroForOne\n            ? Currency.unwrap(data.poolKey.currency1)\n            : Currency.unwrap(data.poolKey.currency0);\n\n        // multiple people could have added tokens to the same order, so we need to calculate the amount to send\n        // total supply = total amount of tokens that were part of the order to be sold\n        // therefore, user\'s share = (amountIn / total supply)\n        // therefore, amount to send to user = (user\'s share * total claimable)\n\n        // amountToSend = amountIn * (total claimable / total supply)\n        // We use FixedPointMathLib.mulDivDown to avoid rounding errors\n        uint256 amountToSend = amountIn.mulDivDown(\n            tokenIdClaimable[tokenId],\n            tokenIdTotalSupply[tokenId]\n        );\n\n        tokenIdClaimable[tokenId] -= amountToSend;\n        tokenIdTotalSupply[tokenId] -= amountIn;\n        _burn(msg.sender, tokenId, amountIn);\n\n        IERC20(tokenToSendContract).transfer(destination, amountToSend);\n    }\n\n    // ERC-1155 Helpers\n    function getTokenId(\n        PoolKey calldata key,\n        int24 tickLower,\n        bool zeroForOne\n    ) public pure returns (uint256) {\n        return\n            uint256(\n                keccak256(abi.encodePacked(key.toId(), tickLower, zeroForOne))\n            );\n    }\n\n    // Utility Helpers\n    function _setTickLowerLast(PoolId poolId, int24 tickLower) private {\n        tickLowerLasts[poolId] = tickLower;\n    }\n\n    function _getTickLower(\n        int24 actualTick,\n        int24 tickSpacing\n    ) private pure returns (int24) {\n        int24 intervals = actualTick / tickSpacing;\n        if (actualTick < 0 && actualTick % tickSpacing != 0) intervals--; // round towards negative infinity\n        return intervals * tickSpacing;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 7:\n\n\n    SUMMARY: Disallows a swap if sender doesn\'t own an ERC721 NFT. This can be used to prevent people from selling tokens that they don\'t own.\n\n    CODE:\n // SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Hooks} from "@uniswap/v4-core/contracts/libraries/Hooks.sol";\nimport {BaseHook} from "v4-periphery/BaseHook.sol";\nimport {IPoolManager} from "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol";\nimport {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";\n\n/// @title ERC721OwnershipHook\ncontract ERC721OwnershipHook is BaseHook {\n    /// @notice NFT contract\n    IERC721 public immutable nftContract;\n\n    error NotNftOwner();\n\n    constructor(\n        IPoolManager _poolManager,\n        IERC721 _nftContract\n    ) BaseHook(_poolManager) {\n        nftContract = _nftContract;\n    }\n\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return\n            Hooks.Calls({\n                beforeInitialize: false,\n                afterInitialize: false,\n                beforeModifyPosition: false,\n                afterModifyPosition: false,\n                beforeSwap: true,\n                afterSwap: false,\n                beforeDonate: false,\n                afterDonate: false\n            });\n    }\n\n    function beforeSwap(\n        address sender,\n        IPoolManager.PoolKey calldata,\n        IPoolManager.SwapParams calldata\n    ) external override returns (bytes4) {\n        if (nftContract.balanceOf(sender) == 0) {\n            revert NotNftOwner();\n        }\n\n        return BaseHook.beforeSwap.selector;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 8:\n\n\n    SUMMARY: A hook that allows users to place limit orders. This means that they can specify the price at which they are willing to buy or sell an asset. If the market price reaches the limit price, the order will be executed.\n\n    CODE:\n // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolId, PoolIdLibrary} from "@uniswap/v4-core/src/types/PoolId.sol";\nimport {Hooks} from "@uniswap/v4-core/src/libraries/Hooks.sol";\nimport {FullMath} from "@uniswap/v4-core/src/libraries/FullMath.sol";\nimport {SafeCast} from "@uniswap/v4-core/src/libraries/SafeCast.sol";\nimport {IERC20Minimal} from "@uniswap/v4-core/src/interfaces/external/IERC20Minimal.sol";\nimport {IERC1155Receiver} from "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol";\nimport {BaseHook} from "../../BaseHook.sol";\nimport {Currency, CurrencyLibrary} from "@uniswap/v4-core/src/types/Currency.sol";\nimport {CurrencySettler} from "@uniswap/v4-core/test/utils/CurrencySettler.sol";\nimport {BalanceDelta} from "@uniswap/v4-core/src/types/BalanceDelta.sol";\nimport {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";\nimport {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";\n\ntype Epoch is uint232;\n\nlibrary EpochLibrary {\n    function equals(Epoch a, Epoch b) internal pure returns (bool) {\n        return Epoch.unwrap(a) == Epoch.unwrap(b);\n    }\n\n    function unsafeIncrement(Epoch a) internal pure returns (Epoch) {\n        unchecked {\n            return Epoch.wrap(Epoch.unwrap(a) + 1);\n        }\n    }\n}\n\ncontract LimitOrder is BaseHook {\n    using EpochLibrary for Epoch;\n    using PoolIdLibrary for PoolKey;\n    using CurrencyLibrary for Currency;\n    using CurrencySettler for Currency;\n    using StateLibrary for IPoolManager;\n\n    error ZeroLiquidity();\n    error InRange();\n    error CrossedRange();\n    error Filled();\n    error NotFilled();\n    error NotPoolManagerToken();\n\n    event Place(\n        address indexed owner, Epoch indexed epoch, PoolKey key, int24 tickLower, bool zeroForOne, uint128 liquidity\n    );\n\n    event Fill(Epoch indexed epoch, PoolKey key, int24 tickLower, bool zeroForOne);\n\n    event Kill(\n        address indexed owner, Epoch indexed epoch, PoolKey key, int24 tickLower, bool zeroForOne, uint128 liquidity\n    );\n\n    event Withdraw(address indexed owner, Epoch indexed epoch, uint128 liquidity);\n\n    bytes internal constant ZERO_BYTES = bytes("");\n\n    Epoch private constant EPOCH_DEFAULT = Epoch.wrap(0);\n\n    mapping(PoolId => int24) public tickLowerLasts;\n    Epoch public epochNext = Epoch.wrap(1);\n\n    struct EpochInfo {\n        bool filled;\n        Currency currency0;\n        Currency currency1;\n        uint256 token0Total;\n        uint256 token1Total;\n        uint128 liquidityTotal;\n        mapping(address => uint128) liquidity;\n    }\n\n    mapping(bytes32 => Epoch) public epochs;\n    mapping(Epoch => EpochInfo) public epochInfos;\n\n    constructor(IPoolManager _manager) BaseHook(_manager) {}\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: false,\n            afterInitialize: true,\n            beforeAddLiquidity: false,\n            beforeRemoveLiquidity: false,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: false,\n            afterSwap: true,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    function getTickLowerLast(PoolId poolId) public view returns (int24) {\n        return tickLowerLasts[poolId];\n    }\n\n    function setTickLowerLast(PoolId poolId, int24 tickLower) private {\n        tickLowerLasts[poolId] = tickLower;\n    }\n\n    function getEpoch(PoolKey memory key, int24 tickLower, bool zeroForOne) public view returns (Epoch) {\n        return epochs[keccak256(abi.encode(key, tickLower, zeroForOne))];\n    }\n\n    function setEpoch(PoolKey memory key, int24 tickLower, bool zeroForOne, Epoch epoch) private {\n        epochs[keccak256(abi.encode(key, tickLower, zeroForOne))] = epoch;\n    }\n\n    function getEpochLiquidity(Epoch epoch, address owner) external view returns (uint256) {\n        return epochInfos[epoch].liquidity[owner];\n    }\n\n    function getTick(PoolId poolId) private view returns (int24 tick) {\n        (, tick,,) = manager.getSlot0(poolId);\n    }\n\n    function getTickLower(int24 tick, int24 tickSpacing) private pure returns (int24) {\n        int24 compressed = tick / tickSpacing;\n        if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n        return compressed * tickSpacing;\n    }\n\n    function afterInitialize(address, PoolKey calldata key, uint160, int24 tick, bytes calldata)\n        external\n        override\n        onlyByManager\n        returns (bytes4)\n    {\n        setTickLowerLast(key.toId(), getTickLower(tick, key.tickSpacing));\n        return LimitOrder.afterInitialize.selector;\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta,\n        bytes calldata\n    ) external override onlyByManager returns (bytes4, int128) {\n        (int24 tickLower, int24 lower, int24 upper) = _getCrossedTicks(key.toId(), key.tickSpacing);\n        if (lower > upper) return (LimitOrder.afterSwap.selector, 0);\n\n        // note that a zeroForOne swap means that the pool is actually gaining token0, so limit\n        // order fills are the opposite of swap fills, hence the inversion below\n        bool zeroForOne = !params.zeroForOne;\n        for (; lower <= upper; lower += key.tickSpacing) {\n            _fillEpoch(key, lower, zeroForOne);\n        }\n\n        setTickLowerLast(key.toId(), tickLower);\n        return (LimitOrder.afterSwap.selector, 0);\n    }\n\n    function _fillEpoch(PoolKey calldata key, int24 lower, bool zeroForOne) internal {\n        Epoch epoch = getEpoch(key, lower, zeroForOne);\n        if (!epoch.equals(EPOCH_DEFAULT)) {\n            EpochInfo storage epochInfo = epochInfos[epoch];\n\n            epochInfo.filled = true;\n\n            (uint256 amount0, uint256 amount1) =\n                _unlockCallbackFill(key, lower, -int256(uint256(epochInfo.liquidityTotal)));\n\n            unchecked {\n                epochInfo.token0Total += amount0;\n                epochInfo.token1Total += amount1;\n            }\n\n            setEpoch(key, lower, zeroForOne, EPOCH_DEFAULT);\n\n            emit Fill(epoch, key, lower, zeroForOne);\n        }\n    }\n\n    function _getCrossedTicks(PoolId poolId, int24 tickSpacing)\n        internal\n        view\n        returns (int24 tickLower, int24 lower, int24 upper)\n    {\n        tickLower = getTickLower(getTick(poolId), tickSpacing);\n        int24 tickLowerLast = getTickLowerLast(poolId);\n\n        if (tickLower < tickLowerLast) {\n            lower = tickLower + tickSpacing;\n            upper = tickLowerLast;\n        } else {\n            lower = tickLowerLast;\n            upper = tickLower - tickSpacing;\n        }\n    }\n\n    function _unlockCallbackFill(PoolKey calldata key, int24 tickLower, int256 liquidityDelta)\n        private\n        onlyByManager\n        returns (uint128 amount0, uint128 amount1)\n    {\n        (BalanceDelta delta,) = manager.modifyLiquidity(\n            key,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: tickLower,\n                tickUpper: tickLower + key.tickSpacing,\n                liquidityDelta: liquidityDelta,\n                salt: 0\n            }),\n            ZERO_BYTES\n        );\n\n        if (delta.amount0() > 0) {\n            manager.mint(address(this), key.currency0.toId(), amount0 = uint128(delta.amount0()));\n        }\n        if (delta.amount1() > 0) {\n            manager.mint(address(this), key.currency1.toId(), amount1 = uint128(delta.amount1()));\n        }\n    }\n\n    function place(PoolKey calldata key, int24 tickLower, bool zeroForOne, uint128 liquidity)\n        external\n        onlyValidPools(key.hooks)\n    {\n        if (liquidity == 0) revert ZeroLiquidity();\n\n        manager.unlock(\n            abi.encodeCall(\n                this.unlockCallbackPlace, (key, tickLower, zeroForOne, int256(uint256(liquidity)), msg.sender)\n            )\n        );\n\n        EpochInfo storage epochInfo;\n        Epoch epoch = getEpoch(key, tickLower, zeroForOne);\n        if (epoch.equals(EPOCH_DEFAULT)) {\n            unchecked {\n                setEpoch(key, tickLower, zeroForOne, epoch = epochNext);\n                // since epoch was just assigned the current value of epochNext,\n                // this is equivalent to epochNext++, which is what\'s intended,\n                // and it saves an SLOAD\n                epochNext = epoch.unsafeIncrement();\n            }\n            epochInfo = epochInfos[epoch];\n            epochInfo.currency0 = key.currency0;\n            epochInfo.currency1 = key.currency1;\n        } else {\n            epochInfo = epochInfos[epoch];\n        }\n\n        unchecked {\n            epochInfo.liquidityTotal += liquidity;\n            epochInfo.liquidity[msg.sender] += liquidity;\n        }\n\n        emit Place(msg.sender, epoch, key, tickLower, zeroForOne, liquidity);\n    }\n\n    function unlockCallbackPlace(\n        PoolKey calldata key,\n        int24 tickLower,\n        bool zeroForOne,\n        int256 liquidityDelta,\n        address owner\n    ) external selfOnly {\n        (BalanceDelta delta,) = manager.modifyLiquidity(\n            key,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: tickLower,\n                tickUpper: tickLower + key.tickSpacing,\n                liquidityDelta: liquidityDelta,\n                salt: 0\n            }),\n            ZERO_BYTES\n        );\n\n        if (delta.amount0() < 0) {\n            if (delta.amount1() != 0) revert InRange();\n            if (!zeroForOne) revert CrossedRange();\n            key.currency0.settle(manager, owner, uint256(uint128(-delta.amount0())), false);\n        } else {\n            if (delta.amount0() != 0) revert InRange();\n            if (zeroForOne) revert CrossedRange();\n            key.currency1.settle(manager, owner, uint256(uint128(-delta.amount1())), false);\n        }\n    }\n\n    function kill(PoolKey calldata key, int24 tickLower, bool zeroForOne, address to) external {\n        Epoch epoch = getEpoch(key, tickLower, zeroForOne);\n        EpochInfo storage epochInfo = epochInfos[epoch];\n\n        if (epochInfo.filled) revert Filled();\n\n        uint128 liquidity = epochInfo.liquidity[msg.sender];\n        if (liquidity == 0) revert ZeroLiquidity();\n        delete epochInfo.liquidity[msg.sender];\n\n        uint256 amount0Fee;\n        uint256 amount1Fee;\n        (amount0Fee, amount1Fee) = abi.decode(\n            manager.unlock(\n                abi.encodeCall(\n                    this.unlockCallbackKill,\n                    (key, tickLower, -int256(uint256(liquidity)), to, liquidity == epochInfo.liquidityTotal)\n                )\n            ),\n            (uint256, uint256)\n        );\n        epochInfo.liquidityTotal -= liquidity;\n        unchecked {\n            epochInfo.token0Total += amount0Fee;\n            epochInfo.token1Total += amount1Fee;\n        }\n\n        emit Kill(msg.sender, epoch, key, tickLower, zeroForOne, liquidity);\n    }\n\n    function unlockCallbackKill(\n        PoolKey calldata key,\n        int24 tickLower,\n        int256 liquidityDelta,\n        address to,\n        bool removingAllLiquidity\n    ) external selfOnly returns (uint128 amount0Fee, uint128 amount1Fee) {\n        int24 tickUpper = tickLower + key.tickSpacing;\n\n        // because `modifyPosition` includes not just principal value but also fees, we cannot allocate\n        // the proceeds pro-rata. if we were to do so, users who have been in a limit order that\'s partially filled\n        // could be unfairly diluted by a user sychronously placing then killing a limit order to skim off fees.\n        // to prevent this, we allocate all fee revenue to remaining limit order placers, unless this is the last order.\n        if (!removingAllLiquidity) {\n            (, BalanceDelta deltaFee) = manager.modifyLiquidity(\n                key,\n                IPoolManager.ModifyLiquidityParams({\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    liquidityDelta: 0,\n                    salt: 0\n                }),\n                ZERO_BYTES\n            );\n\n            if (deltaFee.amount0() > 0) {\n                manager.mint(address(this), key.currency0.toId(), amount0Fee = uint128(deltaFee.amount0()));\n            }\n            if (deltaFee.amount1() > 0) {\n                manager.mint(address(this), key.currency1.toId(), amount1Fee = uint128(deltaFee.amount1()));\n            }\n        }\n\n        (BalanceDelta delta,) = manager.modifyLiquidity(\n            key,\n            IPoolManager.ModifyLiquidityParams({\n                tickLower: tickLower,\n                tickUpper: tickUpper,\n                liquidityDelta: liquidityDelta,\n                salt: 0\n            }),\n            ZERO_BYTES\n        );\n\n        if (delta.amount0() > 0) {\n            key.currency0.take(manager, to, uint256(uint128(delta.amount0())), false);\n        }\n        if (delta.amount1() > 0) {\n            key.currency1.take(manager, to, uint256(uint128(delta.amount1())), false);\n        }\n    }\n\n    function withdraw(Epoch epoch, address to) external returns (uint256 amount0, uint256 amount1) {\n        EpochInfo storage epochInfo = epochInfos[epoch];\n\n        if (!epochInfo.filled) revert NotFilled();\n\n        uint128 liquidity = epochInfo.liquidity[msg.sender];\n        if (liquidity == 0) revert ZeroLiquidity();\n        delete epochInfo.liquidity[msg.sender];\n\n        uint128 liquidityTotal = epochInfo.liquidityTotal;\n\n        amount0 = FullMath.mulDiv(epochInfo.token0Total, liquidity, liquidityTotal);\n        amount1 = FullMath.mulDiv(epochInfo.token1Total, liquidity, liquidityTotal);\n\n        epochInfo.token0Total -= amount0;\n        epochInfo.token1Total -= amount1;\n        epochInfo.liquidityTotal = liquidityTotal - liquidity;\n\n        manager.unlock(\n            abi.encodeCall(\n                this.unlockCallbackWithdraw, (epochInfo.currency0, epochInfo.currency1, amount0, amount1, to)\n            )\n        );\n\n        emit Withdraw(msg.sender, epoch, liquidity);\n    }\n\n    function unlockCallbackWithdraw(\n        Currency currency0,\n        Currency currency1,\n        uint256 token0Amount,\n        uint256 token1Amount,\n        address to\n    ) external selfOnly {\n        if (token0Amount > 0) {\n            manager.burn(address(this), currency0.toId(), token0Amount);\n            manager.take(currency0, to, token0Amount);\n        }\n        if (token1Amount > 0) {\n            manager.burn(address(this), currency1.toId(), token1Amount);\n            manager.take(currency1, to, token1Amount);\n        }\n    }\n\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external view returns (bytes4) {\n        if (msg.sender != address(manager)) revert NotPoolManagerToken();\n        return IERC1155Receiver.onERC1155Received.selector;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 9:\n\n\n    SUMMARY: A unique hook making a Uniswap pool function as an oracle. The geomean price is calculated using the prices of the assets in the pool. This can be used to get a more accurate price for an asset than a single oracle.\n\n    CODE:\n // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";\nimport {PoolId, PoolIdLibrary} from "@uniswap/v4-core/src/types/PoolId.sol";\nimport {Hooks} from "@uniswap/v4-core/src/libraries/Hooks.sol";\nimport {TickMath} from "@uniswap/v4-core/src/libraries/TickMath.sol";\nimport {Oracle} from "../../libraries/Oracle.sol";\nimport {BaseHook} from "../../BaseHook.sol";\nimport {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";\nimport {StateLibrary} from "@uniswap/v4-core/src/libraries/StateLibrary.sol";\nimport {BeforeSwapDelta, BeforeSwapDeltaLibrary} from "@uniswap/v4-core/src/types/BeforeSwapDelta.sol";\n\n/// @notice A hook for a pool that allows a Uniswap pool to act as an oracle. Pools that use this hook must have full range\n///     tick spacing and liquidity is always permanently locked in these pools. This is the suggested configuration\n///     for protocols that wish to use a V3 style geomean oracle.\ncontract GeomeanOracle is BaseHook {\n    using Oracle for Oracle.Observation[65535];\n    using PoolIdLibrary for PoolKey;\n    using StateLibrary for IPoolManager;\n\n    /// @notice Oracle pools do not have fees because they exist to serve as an oracle for a pair of tokens\n    error OnlyOneOraclePoolAllowed();\n\n    /// @notice Oracle positions must be full range\n    error OraclePositionsMustBeFullRange();\n\n    /// @notice Oracle pools must have liquidity locked so that they cannot become more susceptible to price manipulation\n    error OraclePoolMustLockLiquidity();\n\n    /// @member index The index of the last written observation for the pool\n    /// @member cardinality The cardinality of the observations array for the pool\n    /// @member cardinalityNext The cardinality target of the observations array for the pool, which will replace cardinality when enough observations are written\n    struct ObservationState {\n        uint16 index;\n        uint16 cardinality;\n        uint16 cardinalityNext;\n    }\n\n    /// @notice The list of observations for a given pool ID\n    mapping(PoolId => Oracle.Observation[65535]) public observations;\n    /// @notice The current observation array state for the given pool ID\n    mapping(PoolId => ObservationState) public states;\n\n    /// @notice Returns the observation for the given pool key and observation index\n    function getObservation(PoolKey calldata key, uint256 index)\n        external\n        view\n        returns (Oracle.Observation memory observation)\n    {\n        observation = observations[PoolId.wrap(keccak256(abi.encode(key)))][index];\n    }\n\n    /// @notice Returns the state for the given pool key\n    function getState(PoolKey calldata key) external view returns (ObservationState memory state) {\n        state = states[PoolId.wrap(keccak256(abi.encode(key)))];\n    }\n\n    /// @dev For mocking\n    function _blockTimestamp() internal view virtual returns (uint32) {\n        return uint32(block.timestamp);\n    }\n\n    constructor(IPoolManager _manager) BaseHook(_manager) {}\n\n    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {\n        return Hooks.Permissions({\n            beforeInitialize: true,\n            afterInitialize: true,\n            beforeAddLiquidity: true,\n            beforeRemoveLiquidity: true,\n            afterAddLiquidity: false,\n            afterRemoveLiquidity: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false,\n            beforeSwapReturnDelta: false,\n            afterSwapReturnDelta: false,\n            afterAddLiquidityReturnDelta: false,\n            afterRemoveLiquidityReturnDelta: false\n        });\n    }\n\n    function beforeInitialize(address, PoolKey calldata key, uint160, bytes calldata)\n        external\n        view\n        override\n        onlyByManager\n        returns (bytes4)\n    {\n        // This is to limit the fragmentation of pools using this oracle hook. In other words,\n        // there may only be one pool per pair of tokens that use this hook. The tick spacing is set to the maximum\n        // because we only allow max range liquidity in this pool.\n        if (key.fee != 0 || key.tickSpacing != manager.MAX_TICK_SPACING()) revert OnlyOneOraclePoolAllowed();\n        return GeomeanOracle.beforeInitialize.selector;\n    }\n\n    function afterInitialize(address, PoolKey calldata key, uint160, int24, bytes calldata)\n        external\n        override\n        onlyByManager\n        returns (bytes4)\n    {\n        PoolId id = key.toId();\n        (states[id].cardinality, states[id].cardinalityNext) = observations[id].initialize(_blockTimestamp());\n        return GeomeanOracle.afterInitialize.selector;\n    }\n\n    /// @dev Called before any action that potentially modifies pool price or liquidity, such as swap or modify position\n    function _updatePool(PoolKey calldata key) private {\n        PoolId id = key.toId();\n        (, int24 tick,,) = manager.getSlot0(id);\n\n        uint128 liquidity = manager.getLiquidity(id);\n\n        (states[id].index, states[id].cardinality) = observations[id].write(\n            states[id].index, _blockTimestamp(), tick, liquidity, states[id].cardinality, states[id].cardinalityNext\n        );\n    }\n\n    function beforeAddLiquidity(\n        address,\n        PoolKey calldata key,\n        IPoolManager.ModifyLiquidityParams calldata params,\n        bytes calldata\n    ) external override onlyByManager returns (bytes4) {\n        int24 maxTickSpacing = manager.MAX_TICK_SPACING();\n        if (\n            params.tickLower != TickMath.minUsableTick(maxTickSpacing)\n                || params.tickUpper != TickMath.maxUsableTick(maxTickSpacing)\n        ) revert OraclePositionsMustBeFullRange();\n        _updatePool(key);\n        return GeomeanOracle.beforeAddLiquidity.selector;\n    }\n\n    function beforeRemoveLiquidity(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyLiquidityParams calldata,\n        bytes calldata\n    ) external view override onlyByManager returns (bytes4) {\n        revert OraclePoolMustLockLiquidity();\n    }\n\n    function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata, bytes calldata)\n        external\n        override\n        onlyByManager\n        returns (bytes4, BeforeSwapDelta, uint24)\n    {\n        _updatePool(key);\n        return (GeomeanOracle.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n    }\n\n    /// @notice Observe the given pool for the timestamps\n    function observe(PoolKey calldata key, uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n    {\n        PoolId id = key.toId();\n\n        ObservationState memory state = states[id];\n\n        (, int24 tick,,) = manager.getSlot0(id);\n\n        uint128 liquidity = manager.getLiquidity(id);\n\n        return observations[id].observe(_blockTimestamp(), secondsAgos, tick, state.index, liquidity, state.cardinality);\n    }\n\n    /// @notice Increase the cardinality target for the given pool\n    function increaseCardinalityNext(PoolKey calldata key, uint16 cardinalityNext)\n        external\n        returns (uint16 cardinalityNextOld, uint16 cardinalityNextNew)\n    {\n        PoolId id = PoolId.wrap(keccak256(abi.encode(key)));\n\n        ObservationState storage state = states[id];\n\n        cardinalityNextOld = state.cardinalityNext;\n        cardinalityNextNew = observations[id].grow(cardinalityNextOld, cardinalityNext);\n        state.cardinalityNext = cardinalityNextNew;\n    }\n}\n\n\n------------------\n\n\n----------\nHOOK EXAMPLE 10:\n\n\n    SUMMARY: The Whitelist Hook contract is an advanced implementation designed to work seamlessly with Uniswap v4\'s innovative hook system. This contract enables restriction of access to pools based on a whitelist, ensuring that only authorized addresses can interact with the pools.\n\n    CODE:\n // SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport "@openzeppelin/contracts/access/Ownable.sol";\nimport {IPoolManager} from "@uniswap/v4-core/contracts/interfaces/IPoolManager.sol";\nimport {Hooks} from "@uniswap/v4-core/contracts/libraries/Hooks.sol";\nimport {BaseHook} from "../../BaseHook.sol";\nimport {PoolKey} from "@uniswap/v4-core/contracts/types/PoolKey.sol";\n\ncontract WhitelistHook is BaseHook, Ownable {\n\n    mapping(address => bool) public whitelisted;\n\n    event AddedToWhitelist(address indexed addr);\n    event RemovedFromWhitelist(address indexed addr);\n\n    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}\n\n    function addToWhitelist(address _address) external onlyOwner {\n        whitelisted[_address] = true;\n        emit AddedToWhitelist(_address);\n    }\n\n    function removeFromWhitelist(address _address) external onlyOwner {\n        whitelisted[_address] = false;\n        emit RemovedFromWhitelist(_address);\n    }\n\n    function beforeModifyPosition(address sender, PoolKey calldata, IPoolManager.ModifyPositionParams calldata)\n    external\n    override\n    poolManagerOnly\n    returns (bytes4)\n    {\n        require(whitelisted[sender], "WhitelistHook: Not whitelisted");\n        return WhitelistHook.beforeModifyPosition.selector;\n    }\n\n    function beforeSwap(address sender, PoolKey calldata, IPoolManager.SwapParams calldata)\n    external\n    override\n    poolManagerOnly\n    returns (bytes4)\n    {\n        require(whitelisted[sender], "WhitelistHook: Not whitelisted");\n        return WhitelistHook.beforeSwap.selector;\n    }\n\n    function getHooksCalls() public pure override returns (Hooks.Calls memory) {\n        return Hooks.Calls({\n            beforeInitialize: false,\n            afterInitialize: false,\n            beforeModifyPosition: true,\n            afterModifyPosition: false,\n            beforeSwap: true,\n            afterSwap: false,\n            beforeDonate: false,\n            afterDonate: false\n        });\n    }\n}\n\n\n------------------\n\n\nOUTPUT: ONLY Solidity code, nothing else - no explanations, summaries or descriptions. ONLY working Solidity code, WITH comments.'